# 上下文

Perl 6 是上下文敏感的语言，也就是说在不同的上下文中，相同的语句可能会有不同的表现：

强制数字上下文：

    +<a b c> #=> 3;

如果在标量环境下，对一个数组赋值，那么就会出现意想不到的效果：

  my $list = 1, 2, 3;
  say $list; #=> 1

以上的例子说明，变量的前(twigil), 有声明上下文的作用。所以，如果保存
一个列表，最好用 `@var-name` 的形式。在 Perl 5 中，为了追求速度，经常
用引用 (reference) 来保存列表或散列，因为在往函数中传递参数时，引用传递
比值传递更加快速。在 Perl 6 中不存在这个问题，因为在 Perl 6 中，函数的
参数可以指定为传递引用：

    sub sub-name(@array is rw) { }

数组传递到函数中，不再是传递一组参数，而是传入一个参数：

    sub sub-name(@list-one, @list-two, %hash-one) { }

在获取数组或散列的元素时，变量名称也不会发生变化：

    @array[$index]
    %hash{$key}

在 Perl 6 令人羡慕的数组赋值语法之中，隐藏了一个陷阱：

    my @list = 1, 2, 3;

这就是左端变量名称必须以 `@` 开始，否则就坏了：

    my $list = 1, 2, 3; # $list == 1

所以，当对数组进行赋值时，最好是加上括号：

  my @list = [1, 2, 3];

为什么不是圆括号呢？看看下面的例子（.WAHT 表示数据类型)：

    > say (1,2).WHAT
    (Parcel)
    > say [1,2].WHAT
    (Array)
    > say {1,2}.WHAT
    (Block)
    > say {1 => 2}.WHAT
    (Hash)

是不是有点傻眼，Perl 6 看起来人畜无害，但不经意之间，你已经被带到了沟里。

我们不喜欢当孔乙己，去了解语言所有的特性后，在人面前显摆，以彰显自己对
语言的熟悉程度。

其实，对我们有用的数据类型不多，很多数据类型是语言内部
架构的中间类型，没有实际的用处。

我们不必被 Perl 6 这么多的语言特性所迷惑，
真正有用的才是我们要学习的，我们只是想要掌握一门处理实际问题
的工具而已。

